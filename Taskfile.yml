version: '3'

vars:
  pki_max_ttl: "4h"
  postgresql_max_ttl: "24h"
  k8s_role_token_period: 3600
  vault_version_tag: "1.21-ent"
  static_app_count: 3

dotenv:
  - .env

includes:
  eks:
    dir: eks
    taskfile: eks/Taskfile.yml

  gke:
    dir: gke
    taskfile: gke/Taskfile.yml

tasks:
  # ============================================================================
  # Workflow Tasks (Composite)
  # ============================================================================

  default:
    cmd: task --list

  all:
    desc: Run the complete Vault Secrets Operator tutorial
    cmds:
      - task: prerequisites
      - task: minikube
      - task: install
      - task: secrets

  install:
    cmds:
      - task: install:vault
      - task: init:vault
      - task: unseal:vault
      - task: config:vault
      - task: install:vso

  secrets:
    cmds:
      - task: config:static-secret
      - task: deploy:static-secret
      - task: verify:static-secret
      - task: config:dynamic-secret
      - task: deploy:dynamic-secret
      - task: verify:dynamic-secret
      - task: config:csi-secret
      - task: deploy:csi-secret
      - task: verify:csi-secret

  verify:
    cmds:
      - task: verify:pods
      - task: verify:static-secret
      - task: verify:dynamic-secret
      - task: verify:csi-secret

  # ============================================================================
  # Prerequisites & Setup
  # ============================================================================

  prerequisites:
    desc: Check for required tools
    cmds:
      - |
        if ! command -v kubectl &> /dev/null; then
          echo "kubectl could not be found"
          exit 1
        fi
      - |
        if ! command -v helm &> /dev/null; then
          echo "helm could not be found"
          exit 1
        fi
      - |
        if ! command -v minikube &> /dev/null; then
          echo "minikube could not be found"
          exit 1
        fi
      - |
        if [ ! -f .env ]; then
          echo ".env file not found"
          exit 1
        fi
      - echo "All prerequisites found"
      - helm repo add hashicorp https://helm.releases.hashicorp.com
      - helm repo update
    silent: true

  minikube:
    aliases: ["minikube-start", "start"]
    desc: Start minikube cluster
    cmds:
      - |
        if minikube status &> /dev/null; then
          echo "minikube is already running"
        else
          minikube start
        fi
    silent: true

  minikube:stop:
    aliases: ["stop"]
    desc: Stop podman machine
    cmds:
      - minikube stop

  # ============================================================================
  # Vault Installation
  # ============================================================================

  install:vault:
    desc: Install Vault using Helm
    preconditions:
      - test -f vault-ent/vault-license.lic
    cmds:
      - kubectl create namespace vault || true
      - kubectl create secret generic vault-license -n vault --from-file=license=vault-ent/vault-license.lic || true
      - helm repo add hashicorp https://helm.releases.hashicorp.com
      - helm repo update
      - |
        # Detect platform and set storage class accordingly
        CONTEXT=$(kubectl config current-context)
        STORAGE_CLASS_FLAG=""

        if echo "$CONTEXT" | grep -q "minikube"; then
          echo "Detected minikube cluster - using default storage class (standard)"
          STORAGE_CLASS_FLAG=""
        elif echo "$CONTEXT" | grep -Eq "eks|arn:aws"; then
          echo "Detected EKS cluster - using gp2 storage class"
          STORAGE_CLASS_FLAG="--set server.dataStorage.storageClass=gp2"
        elif echo "$CONTEXT" | grep -q "gke"; then
          echo "Detected GKE cluster - using cluster default storage class"
          STORAGE_CLASS_FLAG=""
        else
          echo "Unknown cluster type - using cluster default storage class"
          STORAGE_CLASS_FLAG=""
        fi

        helm upgrade --install vault hashicorp/vault \
          -n vault \
          --values vault-ent/vault-values.yaml \
          --set server.image.tag="{{ .vault_version_tag }}" \
          $STORAGE_CLASS_FLAG
      - sleep 10
      - kubectl wait --for=jsonpath='{.status.phase}'=Running pod -l app.kubernetes.io/name=vault -n vault --timeout=5m
    silent: true

  init:vault:
    desc: Initialize Vault and save keys to vault-init.json
    cmds:
      - |
        if [ -f "vault-init.json" ]; then
            echo "vault-init.json already exists. This means Vault has already been initialized."
            read -p "Do you want to continue and reinitialize Vault? This will overwrite existing keys (y/N): " -r REPLY
            echo
            if ! echo "$REPLY" | grep -qi "^y$"; then
                echo "Initialization cancelled."
                exit 1
            fi
        fi
        kubectl exec vault-0 -n vault -- vault operator init -format=json > vault-init.json
        echo "Vault initialized. Keys saved to vault-init.json"
        VAULT_TOKEN=$(cat vault-init.json | jq -r '.root_token')
        sed -i.bak "s/export VAULT_TOKEN=.*/export VAULT_TOKEN=$VAULT_TOKEN/" .env
        echo "VAULT_TOKEN added to .env file"
        sleep 10
    silent: true

  unseal:vault:
    desc: Unseal Vault using keys from vault-init.json
    preconditions:
      - test -f vault-init.json
    cmds:
      - |
        KEY1=$(cat vault-init.json | jq -r '.unseal_keys_b64[0]')
        KEY2=$(cat vault-init.json | jq -r '.unseal_keys_b64[1]')
        KEY3=$(cat vault-init.json | jq -r '.unseal_keys_b64[2]')
        kubectl exec vault-0 -n vault -- vault operator unseal $KEY1
        kubectl exec vault-0 -n vault -- vault operator unseal $KEY2
        kubectl exec vault-0 -n vault -- vault operator unseal $KEY3
        echo "Vault unsealed successfully"
    silent: true

  # ============================================================================
  # Vault Configuration
  # ============================================================================

  config:vault:
    desc: Configure Vault with Kubernetes auth and secrets
    preconditions:
      - test -f vault-init.json
    cmds:
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN vault audit enable -path='audit_stdout' file file_path=stdout" || true
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN vault namespace create vso" || true
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN vault namespace create tn001" || true
      - kubectl apply -f vault-ent/vault-jwt-service-account.yaml
      - kubectl apply -f vault-ent/vault-jwt-clusterrolebinding.yaml
      - kubectl apply -f vault-ent/vault-jwt-secret.yaml
      - kubectl apply -f vault-ent/oidc-discovery-clusterrolebinding.yaml
      - sleep 5
    env:
      KUBE_HOST:
        sh: kubectl exec vault-0 -n vault -- printenv KUBERNETES_PORT_443_TCP_ADDR
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  config:vso:encrypted-cache:
    desc: Configure Vault transit engine for VSO encrypted client cache in vso namespace
    cmds:
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=vso vault auth enable -path k8s-auth-mount kubernetes" || true
      - |
        TOKEN_REVIEWER_JWT=$(kubectl get secret vault-token-secret -n vault -o json | jq -r .data.token | base64 --decode)
        kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=vso vault write auth/k8s-auth-mount/config \
          kubernetes_host=\"https://$KUBE_HOST:443\" \
          token_reviewer_jwt=\"$TOKEN_REVIEWER_JWT\""
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=vso vault secrets enable -path=vso-transit transit" || true
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=vso vault write -f vso-transit/keys/vso-client-cache"
      - kubectl cp vault-ent/vso-transit-policy.hcl vault-0:/tmp/vso-transit-policy.hcl -n vault
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=vso vault policy write vso-transit /tmp/vso-transit-policy.hcl"
      - |
        kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=vso vault write auth/k8s-auth-mount/role/auth-role-operator \
          alias_name_source=serviceaccount_name \
          bound_service_account_names=vault-secrets-operator-controller-manager \
          bound_service_account_namespaces=vault-secrets-operator \
          policies=vso-transit \
          audience=vault \
          token_period={{ .k8s_role_token_period }}"
    env:
      KUBE_HOST:
        sh: kubectl exec vault-0 -n vault -- printenv KUBERNETES_PORT_443_TCP_ADDR
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'
    silent: true

  config:static-secret:
    cmds:
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault secrets enable -path=kvv2 kv-v2" || true
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault kv put kvv2/webapp/config username=\"static-user\" password=\"static-password\""
      - kubectl cp vault-ent/static-secrets/static-secret.hcl vault-0:/tmp/static-secret.hcl -n vault
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault policy write static-secret /tmp/static-secret.hcl"
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault auth enable -path k8s-auth-mount jwt" || true
      - |
        export ISSUER=$(kubectl get --raw /.well-known/openid-configuration | jq -r '.issuer')
        if kubectl config current-context | grep -q minikube; then
          echo "Detected minikube cluster - using kubernetes service account CA"
          kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault write auth/k8s-auth-mount/config \
            oidc_discovery_url=\"$ISSUER\" \
            oidc_discovery_ca_pem=@/var/run/secrets/kubernetes.io/serviceaccount/ca.crt \
            bound_issuer=\"$ISSUER\""
        else
          echo "Detected non-minikube cluster (EKS/GKE/etc) - using system CA bundle for public OIDC endpoint"
          kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault write auth/k8s-auth-mount/config \
            oidc_discovery_url=\"$ISSUER\" \
            bound_issuer=\"$ISSUER\""
        fi
      - kubectl cp vault-ent/static-secrets/static-secret-role.json vault-0:/tmp/static-secret-role.json -n vault
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault write auth/k8s-auth-mount/role/static-secret @/tmp/static-secret-role.json"
      - |
        for i in $(seq 1 {{ .static_app_count }}); do
          kubectl create ns "static-app-${i}" || true
        done
    env:
      KUBE_HOST:
        sh: kubectl exec vault-0 -n vault -- printenv KUBERNETES_PORT_443_TCP_ADDR
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  config:dynamic-secret:
    preconditions:
      - test -f vault-init.json
    desc: Configure Vault for dynamic database secrets and PKI in tn001 namespace
    cmds:
      - kubectl create ns dynamic-app || true
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault secrets enable -path=db database || echo 'Database secrets engine already enabled'"
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault secrets enable pki || echo 'PKI already enabled'"
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault secrets tune -max-lease-ttl=87600h pki"
      - |
        kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault write -field=certificate pki/root/generate/internal \
          common_name=\"example.com\" \
          ttl=87600h"
      - |
        kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault write pki/roles/example-dot-com \
          allowed_domains=example.com \
          allow_subdomains=true \
          key_type=rsa \
          key_bits=4096 \
          ttl={{ .pki_max_ttl}} \
          max_ttl={{ .pki_max_ttl}}"
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault read sys/mounts/pki/tune"
      - kubectl cp vault-ent/dynamic-secrets/dynamic-secret.hcl vault-0:/tmp/dynamic-secret.hcl -n vault
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault policy write dynamic-secret /tmp/dynamic-secret.hcl"
      - kubectl cp vault-ent/dynamic-secrets/dynamic-secret-role.json vault-0:/tmp/dynamic-secret-role.json -n vault
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault write auth/k8s-auth-mount/role/dynamic-secret @/tmp/dynamic-secret-role.json"
    env:
      KUBE_HOST:
        sh: kubectl exec vault-0 -n vault -- printenv KUBERNETES_PORT_443_TCP_ADDR
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  config:csi-secret:
    preconditions:
      - test -f vault-init.json
    desc: Configure Vault for VSO CSI integration in tn001 namespace
    cmds:
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault kv put kvv2/db-creds username=\"db-user\" password=\"db-secret-password\""
      - kubectl create ns csi-app || true
      - kubectl cp vault-ent/csi-secrets/csi-secret.hcl vault-0:/tmp/csi-secret.hcl -n vault
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault policy write csi-secret /tmp/csi-secret.hcl"
      - kubectl cp vault-ent/csi-secrets/csi-secret-role.json vault-0:/tmp/csi-secret-role.json -n vault
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault write auth/k8s-auth-mount/role/csi-secret @/tmp/csi-secret-role.json"
    env:
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  # ============================================================================
  # VSO Installation
  # ============================================================================

  install:vso:
    desc: Install Vault Secrets Operator with CSI driver enabled
    cmds:
      - task: config:vso:encrypted-cache
      - |
        helm upgrade --install vault-secrets-operator hashicorp/vault-secrets-operator \
          -n vault-secrets-operator \
          --create-namespace \
          --values vault-ent/vault-operator-values.yaml
      - kubectl wait --for=condition=ready pod --all -n vault-secrets-operator --timeout=5m
    silent: true

  # ============================================================================
  # Application Deployment
  # ============================================================================

  deploy:static-secret:
    desc: Deploy static secret resources for all app instances
    cmds:
      - |
        for i in $(seq 1 {{ .static_app_count }}); do
          APP_NAME="static-app-${i}"
          echo "Deploying ${APP_NAME}..."

          # Generate manifests from templates
          sed "s/\${APP_NAME}/${APP_NAME}/g" vault-ent/static-secrets/templates/service-account.yaml.tpl | kubectl apply -f -
          sed "s/\${APP_NAME}/${APP_NAME}/g" vault-ent/static-secrets/templates/vault-auth.yaml.tpl | kubectl apply -f -
          sed "s/\${APP_NAME}/${APP_NAME}/g" vault-ent/static-secrets/templates/static-secret.yaml.tpl | kubectl apply -f -
          sleep 5
          sed "s/\${APP_NAME}/${APP_NAME}/g" vault-ent/static-secrets/templates/deployment.yaml.tpl | kubectl apply -f -
        done
      - sleep 5
      - |
        for i in $(seq 1 {{ .static_app_count }}); do
          APP_NAME="static-app-${i}"
          echo "Waiting for ${APP_NAME} pods to be ready..."
          kubectl wait --for=jsonpath='{.status.phase}'=Running pod -l app=static-app --timeout=2m -n "${APP_NAME}"
        done

  deploy:dynamic-secret:
    desc: Deploy dynamic secret resources with PKI certificates
    cmds:
      - |
        # Detect platform and set storage class for PostgreSQL PVC
        CONTEXT=$(kubectl config current-context)
        STORAGE_CLASS=""

        if echo "$CONTEXT" | grep -q "minikube"; then
          echo "Detected minikube cluster - using standard storage class for PostgreSQL"
          STORAGE_CLASS="standard"
        elif echo "$CONTEXT" | grep -Eq "eks|arn:aws"; then
          echo "Detected EKS cluster - using gp2 storage class for PostgreSQL"
          STORAGE_CLASS="gp2"
        elif echo "$CONTEXT" | grep -q "gke"; then
          echo "Detected GKE cluster - using standard-rwo storage class for PostgreSQL"
          STORAGE_CLASS="standard-rwo"
        else
          echo "Unknown cluster type - using standard storage class for PostgreSQL"
          STORAGE_CLASS="standard"
        fi

        # Apply postgres deployment with templated storage class
        sed "s/\${STORAGE_CLASS}/${STORAGE_CLASS}/g" vault-ent/dynamic-secrets/postgres-deployment.yaml.tpl | kubectl apply -f -
      - sleep 3
      - kubectl wait --for=condition=ready pod --all -n dynamic-app --timeout=5m
      - |
        kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault write db/config/dev-postgres \
          plugin_name=postgresql-database-plugin \
          connection_url='postgresql://{{`{{username}}`}}:{{`{{password}}`}}@postgres.dynamic-app.svc.cluster.local:5432/postgres?sslmode=disable' \
          allowed_roles='dev-postgres' \
          username='postgres' \
          password='secret-pass'"
      - |
        kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault write db/roles/dev-postgres \
          db_name=dev-postgres \
          creation_statements=\"CREATE ROLE \\\"{{`{{name}}`}}\\\" WITH LOGIN PASSWORD '{{`{{password}}`}}' VALID UNTIL '{{`{{expiration}}`}}'; GRANT SELECT ON ALL TABLES IN SCHEMA public TO \\\"{{`{{name}}`}}\\\";\" \
          max_ttl={{ .postgresql_max_ttl }}"
      - kubectl apply -f vault-ent/dynamic-secrets/dynamic-service-account.yaml
      - kubectl apply -f vault-ent/dynamic-secrets/dynamic-vault-auth.yaml
      - kubectl apply -f vault-ent/dynamic-secrets/dynamic-db-secret.yaml
      - kubectl apply -f vault-ent/dynamic-secrets/dynamic-pki-secret.yaml
      - sleep 5
      - kubectl apply -f vault-ent/dynamic-secrets/dynamic-deployment.yaml
      - sleep 5
      - kubectl wait --for=jsonpath='{.status.phase}'=Running pod -l app=dynamic-app --timeout=2m -n dynamic-app
    env:
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  deploy:csi-secret:
    desc: Deploy VSO CSI demo application
    cmds:
      - kubectl apply -f vault-ent/csi-secrets/csi-service-account.yaml
      - kubectl apply -f vault-ent/csi-secrets/csi-vault-auth.yaml
      - kubectl apply -f vault-ent/csi-secrets/csi-secret.yaml
      - sleep 5
      - kubectl apply -f vault-ent/csi-secrets/csi-deployment.yaml
      - sleep 5
      - kubectl wait --for=jsonpath='{.status.phase}'=Running pod -l app=csi-app --timeout=2m -n csi-app
      - sleep 10

  # ============================================================================
  # Verification
  # ============================================================================

  verify:pods:
    desc: Check all pods are in running state
    cmds:
      - kubectl get pods -A

  verify:static-secret:
    desc: Verify the static secret was synced for all app instances
    cmds:
      - |
        for i in $(seq 1 {{ .static_app_count }}); do
          APP_NAME="static-app-${i}"
          echo "=== Verifying ${APP_NAME} ==="
          echo "=== Verifying VaultStaticSecret resource ==="
          kubectl get vaultstaticsecret -n "${APP_NAME}" vault-kv-app -o yaml
          echo ""
          echo "=== Verifying Kubernetes secret created by VSO ==="
          kubectl get secret -n "${APP_NAME}" secretkv -o yaml
          echo ""
          echo "=== Decoding secret values ==="
          echo "Username: $(kubectl get secrets -n ${APP_NAME} secretkv -o jsonpath='{.data.username}' | base64 -d)"
          echo "Password: $(kubectl get secrets -n ${APP_NAME} secretkv -o jsonpath='{.data.password}' | base64 -d)"
          echo ""
        done
      - echo "=== Verifying source secret in Vault namespace tn001 ==="
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault kv get kvv2/webapp/config"
    env:
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'
    silent: true

  verify:dynamic-secret:
    desc: Verify the dynamic secret was synced
    cmds:
      - echo "=== Verifying VaultDynamicSecret resource ==="
      - kubectl get vaultdynamicsecret -n dynamic-app vso-db-demo -o yaml
      - echo "\n=== Verifying Kubernetes secret created by VSO ==="
      - kubectl get secret -n dynamic-app vso-db-demo -o yaml
      - echo "\n=== Decoding secret values ==="
      - |
        echo "Username: $(kubectl get secrets -n dynamic-app vso-db-demo -o jsonpath='{.data.username}' | base64 -d)"
        echo "Password: $(kubectl get secrets -n dynamic-app vso-db-demo -o jsonpath='{.data.password}' | base64 -d)"
      - echo "\n=== Verifying dynamic database secret backend in Vault namespace tn001 ==="
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault read db/creds/dev-postgres"
      - echo "\n=== Verifying VaultPKISecret resource ==="
      - kubectl get vaultpkisecret -n dynamic-app vso-pki-demo -o yaml
      - echo "\n=== Verifying PKI TLS secret created by VSO ==="
      - kubectl get secret -n dynamic-app vso-pki-demo -o yaml
      - echo "\n=== Decoding PKI certificate details ==="
      - |
        echo "Certificate:"
        kubectl get secrets -n dynamic-app vso-pki-demo -o jsonpath='{.data.tls\.crt}' | base64 -d | openssl x509 -text -noout | head -20
      - echo "\n=== Verifying PKI backend in Vault namespace tn001 ==="
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault read pki/roles/example-dot-com"
    env:
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  verify:csi-secret:
    preconditions:
      - test -f vault-init.json
    desc: Verify VSO CSI secrets are mounted and display application logs
    cmds:
      - echo "=== Verifying CSI resources ==="
      - kubectl get csisecrets -n csi-app csi-demo -o yaml
      - echo "\n=== Application logs from pod csi-app/$POD ==="
      - kubectl logs -n csi-app $POD --tail=50
      - echo "\n=== Verifying source secrets in Vault namespace tn001 ==="
      - echo "\n--- KV Secret (kvv2/db-creds) ---"
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault kv get kvv2/db-creds"
    env:
      POD:
        sh: kubectl get pod -l app=csi-app -o jsonpath="{.items[0].metadata.name}" -n csi-app
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  # ============================================================================
  # Operations
  # ============================================================================

  rotate:static-secret:
    desc: Rotate the static secret in Vault
    cmds:
      - |
        kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault kv put kvv2/webapp/config username=\"static-user-$RANDOM\" password=\"static-password-$RANDOM\""
      - sleep 5
      - task: verify:static-secret
    env:
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  rotate:dynamic-secret:
    desc: Rotate the dynamic database secret by revoking leases and restarting the deployment
    cmds:
      - echo "Revoking all database leases for dev-postgres role..."
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault lease revoke -prefix db/creds/dev-postgres"
      - echo "Deleting Kubernetes secret to trigger VSO to fetch new credentials..."
      - kubectl delete secret vso-db-demo -n dynamic-app --ignore-not-found
      - echo "Waiting for VSO to recreate the secret with new credentials..."
      - sleep 10
      - echo "Restarting deployment to pick up new credentials..."
      - kubectl rollout restart deployment dynamic-app -n dynamic-app
      - kubectl rollout status deployment dynamic-app -n dynamic-app --timeout=2m
      - sleep 5
      - task: verify:dynamic-secret
    env:
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  rotate:csi:secret:
    desc: Rotate the CSI secret in Vault
    cmds:
      - |
        kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault kv put kvv2/db-creds username=\"db-user-$RANDOM\" password=\"db-secret-password-$RANDOM\""
      - sleep 5
      - task: verify:csi-secret
    env:
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  restart:csi-secret:
    desc: Rollout restart VSO CSI demo application
    cmds:
      - kubectl rollout restart deployment csi-app -n csi-app

  # ============================================================================
  # Debugging & Monitoring
  # ============================================================================

  status:
    desc: Check Vault status
    cmds:
      - |
        if [ ! -f vault-init.json ]; then
          kubectl exec vault-0 -n vault -- vault status
        else
          export VAULT_TOKEN=$(cat vault-init.json | jq -r '.root_token')
          kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN vault status"
        fi

  logs:
    desc: Follow Vault logs
    cmds:
      - kubectl logs -n vault -l app.kubernetes.io/name=vault -f

  logs:vso:
    desc: Follow Vault Secrets Operator logs
    cmds:
      - kubectl logs -n vault-secrets-operator -l app.kubernetes.io/name=vault-secrets-operator -f

  port-forward:
    desc: Port forward Vault to localhost:8200
    cmds:
      - kubectl port-forward -n vault vault-0 8200:8200

  list:k8s-auth:
    preconditions:
      - test -f vault-init.json
    desc: Display all Kubernetes auth entities
    cmds:
      - echo "=== Kubernetes Auth Methods ==="
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN vault auth list -namespace=tn001"
      - echo "\n=== Kubernetes Auth Roles (k8s-auth-mount) ==="
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN vault list -namespace=tn001 auth/k8s-auth-mount/role"
      - echo "\n=== Kubernetes Auth Config (k8s-auth-mount) ==="
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN vault read -namespace=tn001 auth/k8s-auth-mount/config"
    env:
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  list:identity-entities:
    preconditions:
      - test -f vault-init.json
    desc: Display all identity entities with detailed information
    cmds:
      - |
        echo "=== Identity Entities ==="
        ENTITY_IDS=$(kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN vault list -format=json -namespace=tn001 identity/entity/id" | jq -r '.[]')
        if [ -z "$ENTITY_IDS" ]; then
          echo "No entities found"
        else
          for id in $ENTITY_IDS; do
            echo "\n--- Entity: $id ---"
            kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN vault read -namespace=tn001 identity/entity/id/$id"
          done
        fi
      - |
        echo "\n=== Identity Entity Aliases ==="
        ALIAS_IDS=$(kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN vault list -format=json -namespace=tn001 identity/entity-alias/id" | jq -r '.[]')
        if [ -z "$ALIAS_IDS" ]; then
          echo "No entity aliases found"
        else
          for id in $ALIAS_IDS; do
            echo "\n--- Entity Alias: $id ---"
            kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN vault read -namespace=tn001 identity/entity-alias/id/$id"
          done
        fi
    env:
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'
    silent: true

  events:
    desc: minikube events
    cmds:
      - kubectl get events

  token:
    cmds:
      - jq -r '.root_token' vault-init.json | pbcopy

  ui:
    cmds:
      - task: token
      - open $VAULT_ADDR

  # ============================================================================
  # Uninstallation
  # ============================================================================

  uninstall:
    cmds:
      - task: uninstall:apps
      - task: uninstall:vso
      - sleep 3
      - task:  uninstall:vault
      - sleep 3
      - task: clean:namespaces
    silent: true

  uninstall:vault:
    desc: Uninstall Vault
    cmds:
      - helm uninstall vault -n vault || true
      - kubectl delete pvc --all -n vault --ignore-not-found

      - kubectl delete ns vault || true
      - rm vault-init.json || true

  uninstall:vso:
    desc: Uninstall Vault Secrets Operator
    cmds:
      - helm uninstall vault-secrets-operator -n vault-secrets-operator --ignore-not-found

  uninstall:apps:
    desc: Uninstall k8s apps
    cmds:
      - kubectl delete deployment --all -n csi-app --ignore-not-found
      - kubectl delete deployment --all -n dynamic-app --ignore-not-found
      - kubectl delete pvc --all -n dynamic-app --ignore-not-found
      - kubectl delete pods --all -n csi-app --force --ignore-not-found
      - kubectl delete pods --all -n dynamic-app --force --ignore-not-found
      - kubectl delete vaultauth --all -n csi-app --ignore-not-found || true
      - kubectl delete csisecrets --all -n csi-app --ignore-not-found || true
      - kubectl delete vaultconnection --all -n csi-app --ignore-not-found || true
      - kubectl delete vaultauth --all -n dynamic-app --ignore-not-found || true
      - kubectl delete vaultdynamicsecret --all -n dynamic-app --ignore-not-found || true
      - kubectl delete vaultpkisecret --all -n dynamic-app --ignore-not-found || true
      - |
        for i in $(seq 1 {{ .static_app_count }}); do
          APP_NAME="static-app-${i}"
          echo "Cleaning up ${APP_NAME}..."
          kubectl delete deployment --all -n "${APP_NAME}" --ignore-not-found
          kubectl delete pods --all -n "${APP_NAME}" --force --ignore-not-found
          kubectl delete vaultstaticsecret --all -n "${APP_NAME}" --ignore-not-found || true
          kubectl delete vaultauth --all -n "${APP_NAME}" --ignore-not-found || true
        done
      - sleep 5
      - |
        for i in $(seq 1 {{ .static_app_count }}); do
          APP_NAME="static-app-${i}"
          kubectl delete ns "${APP_NAME}" --ignore-not-found
        done
      - kubectl delete ns dynamic-app --ignore-not-found
      - kubectl delete ns csi-app --ignore-not-found
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault auth disable k8s-auth-mount" || true
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault secrets disable db" || true
      - kubectl exec vault-0 -n vault -- sh -c "VAULT_TOKEN=$VAULT_TOKEN VAULT_NAMESPACE=tn001 vault secrets disable pki" || true
    env:
      VAULT_TOKEN:
        sh: cat vault-init.json | jq -r '.root_token'

  # ============================================================================
  # Cleanup
  # ============================================================================

  clean:
    desc: Remove the minikube cluster
    cmds:
      - minikube delete
      - rm vault-init.json || true

  clean:namespaces:
    desc: Delete application namespaces
    cmds:
      - kubectl delete ns vault-secrets-operator --ignore-not-found
      - kubectl delete ns vault --ignore-not-found
